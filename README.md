# work_3

1. Сортировка выбором (Selection Sort)
Сортировка выбором — это простой метод, который пошагово ищет минимальный элемент из неотсортированной части массива и перемещает его в начало.
Алгоритм последовательно делит массив на две области: отсортированную и неотсортированную.
На каждом шаге:

1. Находим наименьший элемент в неотсортированной части.
2. Меняем его местами с первым элементом этой области.
3. Повторяем процесс, пока весь массив не окажется упорядоченным.

Временная сложность:
`O(n²)`, так как требуется два вложенных цикла — внешний проходит по всем элементам, а внутренний ищет минимум среди оставшихся.
2. Сортировка обменом (Bubble Sort)

Сортировка обменом, или «пузырьковая сортировка», работает по принципу многократного сравнения соседних элементов. Если текущий элемент больше следующего, они меняются местами.
После каждого прохода наибольший элемент «всплывает» в конец массива.
Пошагово:
1. Сравниваются соседние элементы и при необходимости меняются местами.
2. После каждой итерации количество элементов для проверки уменьшается.
3. Если в ходе прохода не было произведено ни одной перестановки — массив уже отсортирован.

Сложность:
`O(n²)` — простой, но неэффективный для больших наборов данных.

3. Сортировка вставками (Insertion Sort)
Сортировка вставками формирует отсортированный список, добавляя элементы один за другим в правильное место.

1. Первый элемент принимается за уже отсортированный.
2. Каждый следующий элемент сравнивается с элементами отсортированной части.
3. Если он меньше, элементы сдвигаются вправо, чтобы освободить место для вставки.

Сложность:
`O(n²)` — из-за многочисленных сравнений и перемещений элементов.
4. Сортировка слиянием (Merge Sort)
Один из самых популярных эффективных алгоритмов, использующий принцип *«разделяй и властвуй»*.

1. Массив делится на две половины.
2. Каждая часть рекурсивно сортируется.
3. Отсортированные половины объединяются в один упорядоченный массив.

Сложность:
`O(n log n)` — благодаря логарифмической глубине рекурсии и линейному времени объединения.

5. Сортировка Шелла (Shell Sort)
Это усовершенствованная версия сортировки вставками, где сравниваются элементы, стоящие друг от друга на некотором расстоянии (шаге).

1. Шаг изначально выбирается равным `n/2`.
2. Элементы сортируются вставками через этот интервал.
3. Шаг постепенно уменьшается до 1.
Когда шаг становится равным единице, массив почти упорядочен, и завершающая сортировка выполняется быстро.
Сложность:
От `O(n log²n)` до `O(n²)` — зависит от выбора последовательности шагов.

6. Быстрая сортировка (Quick Sort)
Быстрая сортировка также реализует стратегию *«разделяй и властвуй»*.

1. Выбирается опорный элемент (pivot).
2. Массив делится на две части: элементы меньше опорного и больше опорного.
3. Обе части сортируются рекурсивно.
Сложность:
Средняя — `O(n log n)`.
В худшем случае (например, при неудачном выборе опорного элемента) — `O(n²)`.

7. Пирамидальная сортировка (Heap Sort)
Этот метод основан на структуре данных «двоичная куча» (heap).

1. Из исходного массива строится максимальная куча, где каждый родитель больше своих потомков.
2. Наибольший элемент (корень) меняется местами с последним элементом массива.
3. Размер кучи уменьшается, и структура восстанавливается (heapify).
Процесс повторяется, пока массив не будет полностью отсортирован.
Сложность:
`O(n log n)` — стабильна для всех случаев.

8. Последовательный поиск (Linear Search)

Простейший способ поиска элемента — проверка каждого значения по порядку.

1. Сравниваем искомый элемент с каждым элементом массива, начиная с первого.
2. Если найдено совпадение — возвращаем индекс.
3. Если конец массива достигнут без совпадения — возвращаем `-1`.

Сложность:
`O(n)` — линейная зависимость от размера массива.
9. Бинарный поиск (Binary Search)
Используется для **отсортированных массивов**. Алгоритм делит диапазон поиска пополам на каждом шаге.

1. Находим средний элемент.
2. Если он равен искомому — успех.
3. Если меньше — ищем справа, если больше — слева.
4. Процесс повторяется, пока диапазон не станет пустым.

Сложность:
`O(log n)` — каждое деление вдвое сокращает область поиска.

10. Интерполирующий поиск (Interpolation Search)

Модификация бинарного поиска, которая лучше работает при **равномерно распределённых данных**.
Вместо середины выбирается позиция, вычисленная по формуле интерполяции — предполагаемое местоположение элемента.

1. Рассчитывается предполагаемый индекс.
2. Проверяется элемент в этой позиции.
3. В зависимости от результата корректируются границы диапазона.

Сложность:
От `O(log log n)` при равномерных данных до `O(n)` в худшем случае.

11. Фибоначчи-поиск (Fibonacci Search)

Вариант бинарного поиска, использующий числа Фибоначчи для разбиения массива.

1. Находится минимальное число Фибоначчи, большее размера массива.
2. Массив делится на части, размеры которых соответствуют соседним числам Фибоначчи.
3. Сравнение проводится с элементом в позиции, определённой этими числами.
4. Поиск продолжается в нужной части массива, пока элемент не найден.
Сложность:
Средняя — `O(log n)`, аналогично бинарному поиску, но иногда эффективнее на практике.

